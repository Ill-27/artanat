<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ARTERII SECURE STARFIELD</title>
    <!-- –ó–∞—â–∏—Ç–∞ –æ—Ç SSR –∏ –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è -->
    <script>
    /*! üîí ARTERRII ULTRA PROTECTION v3.0 */
    (function(){
        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ–º–µ–Ω–∞ (2 —É—Ä–æ–≤–Ω—è)
        const ALLOWED_DOMAINS = ['arterrii.vercel.app', 'arterrii.ru'];
        if (!ALLOWED_DOMAINS.includes(location.hostname) {
            document.write('<h1 style="color:red;font-size:5vw">‚õî ACCESS DENIED</h1>');
            window.stop();
        }

        // 2. –ó–∞—â–∏—Ç–∞ –æ—Ç iframe (–¥–æ–ø–æ–ª–Ω—è–µ—Ç CSP)
        if (window.self !== window.top) {
            document.body.innerHTML = '';
            window.top.location = self.location;
        }

        // 3. –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∫–æ–Ω—Å–æ–ª–∏
        Object.defineProperty(window, 'console', {
            value: new Proxy(console, {
                get: (t, p) => ['log','error','info'].includes(p) 
                    ? () => {} 
                    : t[p]
            })
        });

        // 4. –ó–∞—â–∏—Ç–∞ –≤–æ–¥—è–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤
        const wm = document.createElement('div');
        wm.id = '_wm_protect';
        wm.style.cssText = 'position:fixed;top:0;left:0;width:10px;height:10px;z-index:99999;opacity:0;';
        document.body.prepend(wm);
    })();
    </script>

    <!-- –°—Ç–∏–ª–∏ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è -->
    <style id="_protected_styles">
        body { 
            margin: 0 !important; 
            overflow: hidden !important;
            background: transparent !important;
            touch-action: none !important;
            user-select: none !important;
            font-family: 'Fira Code', monospace !important;
        }
        canvas { 
            display: block !important;
            width: 100vw !important;
            height: 100vh !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
        }
        #watermark {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            pointer-events: none !important;
            z-index: 9999 !important;
        }
    </style>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400&display=swap" crossorigin="anonymous">
</head>
<body>
    <canvas id="starfield"></canvas>
    <div id="watermark"></div>

    <!-- –ó–∞—â–∏—â–µ–Ω–Ω—ã–µ —Å–∫—Ä–∏–ø—Ç—ã -->
    <script>
    /*! üîí ARTERRII CORE PROTECTION */
    (function(){
        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ DOM
        setInterval(() => {
            if (!document.getElementById('_wm_protect') || 
                !document.getElementById('_protected_styles')) {
                document.body.innerHTML = '<h1 style="color:red">SYSTEM TAMPERED</h1>';
                window.stop();
            }
        }, 1500);

        // 2. –ó–∞—â–∏—Ç–∞ –æ—Ç –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
        document.addEventListener('copy', e => {
            e.clipboardData.setData('text/plain', '¬© ARTERRII PROTECTED CONTENT');
            e.preventDefault();
        });
        document.addEventListener('contextmenu', e => e.preventDefault());

        // 3. –ê–Ω—Ç–∏-–æ—Ç–ª–∞–¥–∫–∞
        const devToolsCheck = () => {
            const threshold = 160;
            if (window.outerWidth - window.innerWidth > threshold || 
                window.outerHeight - window.innerHeight > threshold) {
                document.body.innerHTML = '';
                window.stop();
            }
        };
        setInterval(devToolsCheck, 500);
    })();
    </script>

    <!-- Three.js —Å –∑–∞—â–∏—Ç–æ–π —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js" integrity="sha384-7Mm0WZ0Q1yN9Fj+Udkp9D4zVhBZ+hR6iWRCYON96W+cp7l5ng5Pk5Ps7ELh5V4h3" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/FontLoader.js" integrity="sha384-+q9j8K0QqCl5YDBJyRk/6AlQ+6dXj3WhUQLQ5P5ZL5U5Y5e5h5Y5e5h5Y5e5h5Y5" crossorigin="anonymous"></script>

    <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–¥ —Å –∑–∞—â–∏—Ç–æ–π -->
    <script>
    /*! üîí ARTERRII MAIN CODE */
    (function(){
        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ Three.js
        if (typeof THREE !== 'object' || !THREE.Scene) {
            document.body.innerHTML = '<h1>THREE.JS TAMPERED</h1>';
            throw new Error('Invalid THREE.js');
        }

        // 2. –ó–∞–º–æ—Ä–æ–∑–∫–∞ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        Object.freeze(THREE);
        Object.freeze(THREE.Scene.prototype);

        // 3. –ó–∞—â–∏—Ç–∞ –æ—Ç –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏
        const originalSetup = {
            compileShader: THREE.WebGLRenderer.prototype.compileShader,
            render: THREE.WebGLRenderer.prototype.render
        };

      // ================= WEBGL STARFIELD ================= //
    const canvas = document.getElementById('starfield');
    const gl = canvas.getContext('webgl', { preserveDrawingBuffer: false });

    if (!gl) {
        document.body.innerHTML = '<h1 style="color:red">WebGL not supported</h1>';
        throw new Error('WebGL not supported');
    }

    // –®–µ–π–¥–µ—Ä—ã –¥–ª—è –∑–≤–µ–∑–¥–Ω–æ–≥–æ –ø–æ–ª—è
    const vertexShader = `
        attribute vec3 aPosition;
        attribute float aSize;
        attribute float aAlpha;
        attribute float aColorIndex;
        
        uniform mat4 uProjection;
        uniform mat4 uModelView;
        uniform float uTime;
        
        varying float vAlpha;
        varying float vColorIndex;
        
        void main() {
            vec4 pos = uModelView * vec4(aPosition, 1.0);
            pos.xyz += sin(uTime * 0.001 + aColorIndex * 10.0) * 5.0;
            gl_Position = uProjection * pos;
            gl_PointSize = aSize * (1.5 + sin(uTime * 0.005 + aColorIndex) * 0.5);
            vAlpha = aAlpha;
            vColorIndex = aColorIndex;
        }
    `;

    const fragmentShader = `
        precision highp float;
        
        uniform float uTime;
        varying float vAlpha;
        varying float vColorIndex;
        
        vec3 getColor(float index) {
            int colorType = int(mod(index * 10.0, 7.0));
            
            if (colorType == 0) return vec3(0.5, 0.0, 1.0);   // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            if (colorType == 1) return vec3(0.0, 0.0, 1.0);   // –°–∏–Ω–∏–π
            if (colorType == 2) return vec3(0.0, 0.75, 1.0);  // –ì–æ–ª—É–±–æ–π
            if (colorType == 3) return vec3(0.0, 1.0, 0.5);   // –ó–µ–ª–µ–Ω—ã–π
            if (colorType == 4) return vec3(1.0, 1.0, 0.0);   // –ñ–µ–ª—Ç—ã–π
            if (colorType == 5) return vec3(1.0, 0.38, 0.0);  // –û—Ä–∞–Ω–∂–µ–≤—ã–π
            if (colorType == 6) return vec3(1.0, 0.0, 0.0);   // –ö—Ä–∞—Å–Ω—ã–π
            
            return vec3(0.9); // –ë–µ–ª—ã–π
        }
        
        void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            
            float alpha = vAlpha * (0.6 + 0.4 * sin(uTime * 0.002 + vColorIndex * 10.0));
            vec3 color = mix(vec3(0.9), getColor(vColorIndex), step(0.93, vColorIndex));
            
            gl_FragColor = vec4(color, alpha * (1.0 - smoothstep(0.3, 0.5, dist)));
        }
    `;

    // –ö–æ–º–ø–∏–ª—è—Ü–∏—è —à–µ–π–¥–µ—Ä–æ–≤
    function compileShader(gl, source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const vs = compileShader(gl, vertexShader, gl.VERTEX_SHADER);
    const fs = compileShader(gl, fragmentShader, gl.FRAGMENT_SHADER);
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
    }
    
    gl.useProgram(program);

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–≤–µ–∑–¥
    const STARS_COUNT = 7000;
    const positions = new Float32Array(STARS_COUNT * 3);
    const sizes = new Float32Array(STARS_COUNT);
    const alphas = new Float32Array(STARS_COUNT);
    const colorIndices = new Float32Array(STARS_COUNT);

    for (let i = 0; i < STARS_COUNT; i++) {
        positions[i*3] = (Math.random() - 0.5) * 2500;
        positions[i*3+1] = (Math.random() - 0.5) * 2500;
        positions[i*3+2] = (Math.random() - 0.5) * 2500;
        
        sizes[i] = 0.8 + Math.random() * 1.4;
        alphas[i] = 0.7 + Math.random() * 0.3;
        colorIndices[i] = Math.random();
    }

    // –ë—É—Ñ–µ—Ä—ã
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    
    const sizeBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);
    
    const alphaBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, alphas, gl.STATIC_DRAW);
    
    const colorIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorIndexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, colorIndices, gl.STATIC_DRAW);

    // –ê—Ç—Ä–∏–±—É—Ç—ã
    const aPosition = gl.getAttribLocation(program, 'aPosition');
    gl.enableVertexAttribArray(aPosition);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
    
    const aSize = gl.getAttribLocation(program, 'aSize');
    gl.enableVertexAttribArray(aSize);
    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
    gl.vertexAttribPointer(aSize, 1, gl.FLOAT, false, 0, 0);
    
    const aAlpha = gl.getAttribLocation(program, 'aAlpha');
    gl.enableVertexAttribArray(aAlpha);
    gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
    gl.vertexAttribPointer(aAlpha, 1, gl.FLOAT, false, 0, 0);
    
    const aColorIndex = gl.getAttribLocation(program, 'aColorIndex');
    gl.enableVertexAttribArray(aColorIndex);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorIndexBuffer);
    gl.vertexAttribPointer(aColorIndex, 1, gl.FLOAT, false, 0, 0);

    // –Æ–Ω–∏—Ñ–æ—Ä–º—ã
    const uProjection = gl.getUniformLocation(program, 'uProjection');
    const uModelView = gl.getUniformLocation(program, 'uModelView');
    const uTime = gl.getUniformLocation(program, 'uTime');

    // –ú–∞—Ç—Ä–∏—Ü—ã
    const projection = new Float32Array(16);
    const modelView = new Float32Array(16);
    
    function updateMatrix() {
        const fov = 75 * Math.PI / 180;
        const aspect = canvas.width / canvas.height;
        const near = 0.1;
        const far = 10000;
        
        // Projection matrix
        const f = 1.0 / Math.tan(fov / 2);
        projection.fill(0);
        projection[0] = f / aspect;
        projection[5] = f;
        projection[10] = (far + near) / (near - far);
        projection[11] = -1;
        projection[14] = (2 * far * near) / (near - far);
        
        // ModelView matrix
        modelView.fill(0);
        modelView[0] = 1;
        modelView[5] = 1;
        modelView[10] = 1;
        modelView[15] = 1;
        modelView[14] = -1200;
    }

    // –í–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // –†–µ–Ω–¥–µ—Ä –∑–≤–µ–∑–¥–Ω–æ–≥–æ –ø–æ–ª—è
    let time = 0;
    function renderStars() {
        time += 16;
        
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        // –í—Ä–∞—â–µ–Ω–∏–µ
        const speed = 0.009;
        modelView[0] = Math.cos(time * speed * 0.15);
        modelView[2] = Math.sin(time * speed * 0.09);
        modelView[8] = -Math.sin(time * speed * 0.1);
        modelView[10] = Math.cos(time * speed * 0.09);
        
        gl.uniformMatrix4fv(uProjection, false, projection);
        gl.uniformMatrix4fv(uModelView, false, modelView);
        gl.uniform1f(uTime, time);
        
        gl.drawArrays(gl.POINTS, 0, STARS_COUNT);
        requestAnimationFrame(renderStars);
    }

    // –†–µ—Å–∞–π–∑
    function resize() {
        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        updateMatrix();
    }
    
    window.addEventListener('resize', resize);
    resize();
    updateMatrix();
    renderStars();

    // ================= –í–û–î–Ø–ù–´–ï –ó–ù–ê–ö–ò (–¢–û–ß–ù–ê–Ø –ö–û–ü–ò–Ø –í–ê–®–ï–ì–û –û–†–ò–ì–ò–ù–ê–õ–ê) ================= //
    const watermarkScene = new THREE.Scene();
    const watermarkCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    watermarkCamera.position.z = 20;
    
    const watermarkRenderer = new THREE.WebGLRenderer({ 
        alpha: true,
        antialias: true,
        powerPreference: "high-performance"
    });
    watermarkRenderer.setSize(window.innerWidth, window.innerHeight);
    watermarkRenderer.domElement.style.position = 'fixed';
    watermarkRenderer.domElement.style.top = '0';
    watermarkRenderer.domElement.style.left = '0';
    watermarkRenderer.domElement.style.zIndex = '9999';
    watermarkRenderer.domElement.style.pointerEvents = 'none';
    watermarkRenderer.domElement.style.opacity = '0.7';
    document.getElementById('watermark').appendChild(watermarkRenderer.domElement);

    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ–¥—è–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤ (—Ç–æ—á–Ω–∞—è –∫–æ–ø–∏—è)
    const watermarkConfig = {
        columns: 12,
        rows: 8,
        baseSize: 0.15,
        speed: 0.01,
        drift: 0.03,
        opacity: 0.6,
        colors: [
            new THREE.Color(0.95, 0.95, 1.0),
            new THREE.Color(1.0, 1.0, 1.0),
            new THREE.Color(0.9, 0.95, 1.0)
        ],
        updateInterval: 50
    };

    // –ö–ª–∞—Å—Å –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ (—Ç–æ—á–Ω–∞—è –∫–æ–ø–∏—è)
    class SeamlessWatermark {
        constructor(font) {
            this.font = font;
            this.meshes = [];
            this.timeElements = [];
            this.lastUpdate = 0;
            this.initSeamlessGrid();
            this.setupProtection();
        }
        
        initSeamlessGrid() {
            const texts = [
                'Arterrrii', 'arterrii.ru', 
                this.generateId(),
                'v.1.9.5.25'
            ];
            
            const columnWidth = 80 / watermarkConfig.columns;
            const rowHeight = 60 / watermarkConfig.rows;
            
            for (let col = 0; col < watermarkConfig.columns; col++) {
                for (let row = 0; row < watermarkConfig.rows * 1.5; row++) {
                    const isTime = (col % 3 === 0 && row % 5 === 0);
                    const text = isTime ? this.getCurrentTime() : 
                               texts[Math.floor(Math.random() * texts.length)];
                    
                    this.createWatermark(
                        text,
                        -40 + col * columnWidth + (Math.random() - 0.5) * columnWidth * 0.8,
                        30 - row * rowHeight * 0.6 + (Math.random() - 0.5) * rowHeight * 0.4,
                        isTime
                    );
                }
            }
        }
        
        createWatermark(text, x, y, isTime) {
            const size = watermarkConfig.baseSize * (0.8 + Math.random() * 0.5);
            const color = watermarkConfig.colors[
                Math.floor(Math.random() * watermarkConfig.colors.length)
            ].clone();
            
            const geometry = new THREE.TextGeometry(text, {
                font: this.font,
                size: size,
                height: 0.01,
                curveSegments: 4
            });
            
            this.addSubtleNoise(geometry);
            
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: watermarkConfig.opacity * (0.9 + Math.random() * 0.2),
                blending: THREE.NormalBlending
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(x, y, (Math.random() - 0.5) * 20);
            
            mesh.userData = {
                speed: watermarkConfig.speed * (0.8 + Math.random() * 0.4),
                drift: watermarkConfig.drift * (0.5 + Math.random()),
                phase: Math.random() * Math.PI * 2,
                isTime: isTime,
                originalText: text,
                color: color,
                size: size,
                initialY: y
            };
            
            watermarkScene.add(mesh);
            this.meshes.push(mesh);
            if (isTime) this.timeElements.push(mesh);
        }
        
        addSubtleNoise(geometry) {
            const position = geometry.attributes.position;
            const noiseIntensity = 0.03;
            
            for (let i = 0; i < position.count; i++) {
                position.setZ(i, (Math.random() - 0.5) * noiseIntensity);
            }
            position.needsUpdate = true;
        }
        
        update(deltaTime) {
            if (deltaTime - this.lastUpdate > watermarkConfig.updateInterval) {
                const timeStr = this.getCurrentTime();
                this.timeElements.forEach(mesh => {
                    this.updateText(mesh, timeStr);
                });
                this.lastUpdate = deltaTime;
            }
            
            this.meshes.forEach(mesh => {
                this.animateWatermark(mesh, deltaTime);
            });
        }
        
        updateText(mesh, newText) {
            mesh.geometry.dispose();
            mesh.geometry = new THREE.TextGeometry(newText, {
                font: this.font,
                size: mesh.userData.size,
                height: 0.01,
                curveSegments: 4
            });
            this.addSubtleNoise(mesh.geometry);
            mesh.userData.originalText = newText;
        }
        
        animateWatermark(mesh, time) {
            const ud = mesh.userData;
            
            mesh.position.y -= ud.speed;
            mesh.position.x += Math.cos(time * 0.001 + ud.phase) * ud.drift * 0.3;
            
            if (mesh.position.y < -30) {
                mesh.position.y = 30;
                mesh.position.x = ud.initialY + (Math.random() - 0.5) * 5;
            }
            
            mesh.material.opacity = watermarkConfig.opacity * 
                (0.9 + Math.sin(time * 0.003 + ud.phase) * 0.1);
            
            if (Math.random() > 0.98) {
                mesh.material.color.offsetHSL(0, (Math.random() - 0.5) * 0.05, 0);
            }
        }
        
        getCurrentTime() {
            const now = new Date();
            return now.toLocaleTimeString('ru-RU', { hour12: false });
        }
        
        generateId() {
            return 'ID-' + Array.from({length: 12}, () => 
                Math.floor(Math.random() * 16).toString(16)).join('');
        }
        
        setupProtection() {
            setInterval(() => {
                if (!document.getElementById('watermark').contains(watermarkRenderer.domElement)) {
                    document.getElementById('watermark').appendChild(watermarkRenderer.domElement);
                }
            }, 1000);
            
            document.addEventListener('copy', (e) => {
                e.clipboardData.setData('text/plain', '¬© ARTERRII Protected Content');
                e.preventDefault();
            });
            
            document.body.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && (e.key === 'PrintScreen' || e.key === 's')) {
                    e.preventDefault();
                }
            });
        }
    }

    // –ó–∞–≥—Ä—É–∑–∫–∞ —à—Ä–∏—Ñ—Ç–∞ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–æ–¥—è–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤
    new THREE.FontLoader().load(
        'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/fonts/helvetiker_regular.typeface.json', 
        (font) => {
            const watermarkSystem = new SeamlessWatermark(font);
            
            let lastTime = 0;
            function animateWatermarks(currentTime) {
                requestAnimationFrame(animateWatermarks);
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                
                watermarkSystem.update(currentTime);
                watermarkRenderer.render(watermarkScene, watermarkCamera);
            }
            
            animateWatermarks(0);
        }
    );

    // –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å –≤–æ–¥—è–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤
    window.addEventListener('resize', () => {
        watermarkCamera.aspect = window.innerWidth / window.innerHeight;
        watermarkCamera.updateProjectionMatrix();
        watermarkRenderer.setSize(window.innerWidth, window.innerHeight);
    });

        // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –∫–æ–¥–∞
        const CODE_HASH = 'e7f7bc86e8cee12aacc90f7d7176b8aa25a373092e8f132edf224864dfb4b177'; // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π —Ö–µ—à
        fetch(location.href)
            .then(r => r.text())
            .then(t => {
                const hash = sha256(t);
                if (hash !== CODE_HASH) {
                    document.body.innerHTML = '<h1>CODE MODIFIED</h1>';
                    window.stop();
                }
            });

        function sha256(str) {
            // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
            return CryptoJS.SHA256(str).toString();
        }
    })();
    </script>

    <!-- –ó–∞—â–∏—Ç–∞ –æ—Ç –≤—Å—Ç–∞–≤–∫–∏ –≤ iframe (—Ä–µ–∑–µ—Ä–≤–Ω–∞—è) -->
    <script>
    if (window.self !== window.top) {
        document.body.innerHTML = '';
        window.top.location = self.location;
    }
    </script>
</body>
</html>
